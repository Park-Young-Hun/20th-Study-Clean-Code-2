# 🏌️ Clean Code - DAY 04
## ✨SOLID

1. SRP 단일 책임 원칙
    - 한 클래스는 하나의 책임(기능)만 가져야 한다.
    - But 하나의 책임이라는 것은 모호함.
        - 문맥과 상황에 따라 다를 수 있다.
    - **중요한 기준은 변경!**
        - 변경이 생길 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
2. OCP 개방-폐쇄 원칙
    - 확장에는 열려있고 변경에는 닫혀 있어야 한다.
    - 역할과 구현의 분리 (인터페이스 설계)
    - 다형성을 이용
3. LSP 리스코프 치환원칙
    - 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
    - 다형성에서 하위 클래스는 상위 인터페이스의 규약을 다 지켜야 한다.
        - 이 원칙을 만족해야 다형성을 이용하여 인터페이스를 구현한 구현체를 믿고 호출할 수 있다.
        - ex) 자동차 액셀 인터페이스를 구현한 구현체가 뒤로 가는 기능을 구현하면 안됨.
4. ISP 인터페이스 분리 원칙
    - SRP의 인터페이스 버전
    - 구현체가 필요한 인터페이스만 구현할 수 있도록 최소 기능 단위로 분리해야 한다.
5. DIP 의존관계 역전 원칙
    - 추상화에 의존해야지 구체화에 의존하면 안된다.
    - 구현 클래스에 의존하지말고, 인터페이스에 의존해야한다.
    - 역할과 구현을 분리 했을 때 **역할에 의존!**

<br>


## 🐱‍🏍간결하고 안전한 함수 작성하기

- SRP OCP 만족
    - 기능 단위로 작게 쪼갠다.
    - 함수 내 추상화 수준을 동일하게 맞춘다.
- 함수 인수 갯수
    - 0-2개가 적당하다.
    - 3개 이상인 경우 클래스를 만들어 객체를 인자로 넘기자.
    
    ```jsx
    Circle makeCircle(double x, double y, double radius);
    Circle makeCircle(Point center, double radius);
    ```
    
- Side Effect가 없는 함수
    - 값을 반환하는 함수는 그것만 하고 외부상태를 변경하면 안된다.
- 함수 리팩터링 순서
    1. 기능을 구현
    2. 테스트 코드를 작성
    3. 리팩터링 (테스트를 여전히 만족시키면서)
    - TDD와 상반된 순서
